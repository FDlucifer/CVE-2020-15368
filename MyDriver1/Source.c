#include <ntifs.h>
#include <Ntddk.h>
#include <wdm.h>
#include <ntimage.h>

#include "proto.h"

// CHONST!!!!!!!!
#define chonstexpr constexpr
#define chonst const
#define reinterpret_chast reinterpret_cast

// driver mapper shellcode
__int64 __declspec(dllexport) __fastcall MyIRPHandler(struct _DEVICE_OBJECT* a1, IRP* irp)
{
    ULONG ioctl_no = irp->Tail.Overlay.CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode;
    MyIrpStruct* user_data = (MyIrpStruct*)irp->AssociatedIrp.SystemBuffer;

    void* my_rwx = user_data->nt_ExAllocatePoolWithTag(NonPagedPoolExecute, user_data->payload_size, 'lmao');

    user_data->nt_memcpy(my_rwx, user_data->payload, user_data->payload_size);

    // do relocs
    PIMAGE_DOS_HEADER image = (PIMAGE_DOS_HEADER)my_rwx;
    PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS)((uintptr_t)my_rwx + image->e_lfanew);
    IMAGE_DATA_DIRECTORY* reloc_dir_info = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    IMAGE_BASE_RELOCATION* relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)my_rwx + reloc_dir_info->VirtualAddress);

    uintptr_t basediff = (uintptr_t)my_rwx - pe->OptionalHeader.ImageBase;

    void* relocs_end = (void*)((uintptr_t)relocs + reloc_dir_info->Size);
    while (relocs < relocs_end)
    {
        ULONG va = relocs->VirtualAddress;
        USHORT* entries = (USHORT*)((uintptr_t)relocs + sizeof(IMAGE_BASE_RELOCATION));
        int num_entries = (relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
        for (int i = 0; i < num_entries; i++)
        {
            USHORT entry = entries[i];
            USHORT reloc_type = entry >> 12;
            uintptr_t reloc_offset = (uintptr_t)(entry & 0xfff);
            if (reloc_type == IMAGE_REL_BASED_DIR64)
            {
                ULONG64* reloc_spot = (ULONG64*)((uintptr_t)my_rwx + va + reloc_offset);
                *reloc_spot += basediff;
            }
            else if (reloc_type == IMAGE_REL_BASED_ABSOLUTE)
            {
                // this is padding, skip
            }
            else
            {
                // this should never happen
                __debugbreak();
            }
        }
        relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)relocs + relocs->SizeOfBlock);
    }

    // allocate start context
    void* my_startcontext = user_data->nt_ExAllocatePoolWithTag(NonPagedPoolExecute, sizeof(MyIrpStruct), 'lmao');
    memcpy(my_startcontext, user_data, sizeof(MyIrpStruct));

    // start thread
    HANDLE hThread;
    void* start_addr = (void*)((uintptr_t)my_rwx + 0x1000);
    user_data->nt_PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)start_addr, my_startcontext);

    ((void (*)(PIRP, CCHAR))user_data->nt_IofCompleteRequest)(irp, 0);

    return 0;
}



// actual driver shit

LPCSTR NTSYSAPI NTAPI PsGetProcessImageFileName(PEPROCESS Process);

#define DBG_LOG(fmt, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[rose][" __FUNCTION__ "] " fmt "\n", ##__VA_ARGS__)

void* MyRegistrationHandle;
void* MyRegistrationContext;

UCHAR Trampoline[] = {
    0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, imm64
    0xff, 0xe0 // jmp rax
};

#include <intrin.h>

volatile int IsUnloading = 0;
PVOID MyCreateProcessNotifyRoutine_Handle = 0;

void MyCreateProcessNotifyRoutine(
    PEPROCESS Process,
    HANDLE ProcessId,
    PPS_CREATE_NOTIFY_INFO CreateInfo
)
{
    if (!CreateInfo)
    {
        DBG_LOG("Process exiting: %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));
        return;
    }
    
    DBG_LOG("Process created: %p %d (%s)", Process, ProcessId, PsGetProcessImageFileName(Process));
    HANDLE CreatingProcessId = CreateInfo->CreatingThreadId.UniqueProcess;
    PEPROCESS CreatingProcess;
    DBG_LOG("  Created by: pid %p", CreatingProcessId);
    NTSTATUS Result = PsLookupProcessByProcessId(CreatingProcessId, &CreatingProcess);
    if (Result != STATUS_SUCCESS)
    {
        DBG_LOG("PsLookupProcessByProcessId fails?? ntstatus=%x", Result);
        return;
    }
    DBG_LOG("  Created by: %s, pid %p", PsGetProcessImageFileName(CreatingProcess), CreatingProcessId);
    ObDereferenceObject(CreatingProcess);

    // TODO: Whitelist creating process in ObRegisterCallbacks and deny all other handles
}


NTSTATUS MyUnloadRoutine(void* my_start_info)
{
    DBG_LOG("My unload thread runs.");
    LARGE_INTEGER interval;
    interval.QuadPart = -10000 * 100;
    KeDelayExecutionThread(KernelMode, FALSE, &interval);

    DBG_LOG("Now we call ObUnRegisterCallbacks.");
    ObUnRegisterCallbacks(MyRegistrationHandle);

    DBG_LOG("Now we call PsSetCreateProcessNotifyRoutineEx.");
    PsSetCreateProcessNotifyRoutineEx(MyCreateProcessNotifyRoutine_Handle, TRUE);

    DBG_LOG("OK MyUnloadRoutine completes.");
    return STATUS_SUCCESS;
}

#define DELETE                           (0x00010000L)
#define READ_CONTROL                     (0x00020000L)
#define WRITE_DAC                        (0x00040000L)
#define WRITE_OWNER                      (0x00080000L)
#define STANDARD_RIGHTS_REQUIRED         (0x000F0000L)
#define SYNCHRONIZE                      (0x00100000L)
#define PROCESS_TERMINATE                  (0x0001)  
#define PROCESS_CREATE_THREAD              (0x0002)  
#define PROCESS_SET_SESSIONID              (0x0004)  
#define PROCESS_VM_OPERATION               (0x0008)  
#define PROCESS_VM_READ                    (0x0010)  
#define PROCESS_VM_WRITE                   (0x0020)  
#define PROCESS_DUP_HANDLE                 (0x0040)  
#define PROCESS_CREATE_PROCESS             (0x0080)  
#define PROCESS_SET_QUOTA                  (0x0100)  
#define PROCESS_SET_INFORMATION            (0x0200)  
#define PROCESS_QUERY_INFORMATION          (0x0400)  
#define PROCESS_SUSPEND_RESUME             (0x0800)  
#define PROCESS_QUERY_LIMITED_INFORMATION  (0x1000)  
#define PROCESS_SET_LIMITED_INFORMATION    (0x2000)

typedef void _HANDLE_TABLE;
typedef void _HANDLE_TABLE_ENTRY;
__int64 extern ExEnumHandleTable(_HANDLE_TABLE* HandleTable, unsigned __int8(__fastcall* EnumHandleProcedure)(_HANDLE_TABLE*, _HANDLE_TABLE_ENTRY*, void*, void*), void* EnumParameter, void** Handle);

typedef struct _HANDLE_TABLE_ENTRY
{
    void* ObjectPtr;
    ULONG GrantedAccess;
} *PHANDLE_TABLE_ENTRY;

extern void* ObGetObjectType(void* Object);

__int64 (NTAPI* ExUnlockHandleTableEntry)(__int64 HandleTable, volatile signed __int64* HandleTableEntry) = 0;

BOOLEAN MyEnumHandleProcedure(
    _HANDLE_TABLE* HandleTable,
    PHANDLE_TABLE_ENTRY HandleTableEntry,
    HANDLE Handle,
    PVOID EnumParameter)
{
    PEPROCESS OwningProcess = EnumParameter;

    void* Object = (((__int64)HandleTableEntry->ObjectPtr >> 16LL) & 0xFFFFFFFFFFFFFFF0ui64) + 0x30;
    //DBG_LOG("Handle %p HandleTableEntry=%p %p Access %x", Handle, HandleTableEntry, Object, HandleTableEntry->GrantedAccess);
    if (!MmIsAddressValid(Object))
        goto exit_func;
    void* ObjectType = ObGetObjectType(Object);
    //DBG_LOG("ObjectType %p", ObjectType);
    if (!MmIsAddressValid(ObjectType))
        goto exit_func;
    UCHAR ObjectTypeIndex = *(UCHAR*)((uintptr_t)ObjectType + 0x28);
    //DBG_LOG("ObjectTypeIndex %x", ObjectTypeIndex);

    if (ObjectTypeIndex == 7) // Process
    {
        PEPROCESS kp = (PEPROCESS)Object; // sizeof(_OBJECT_HEADER)
        //DBG_LOG("KPROCESS = %p", kp);
        if (!strcmp(PsGetProcessImageFileName(kp), "notepad.exe"))
        {
            DBG_LOG("Found process %s holding handle to protected process %s", PsGetProcessImageFileName(OwningProcess), PsGetProcessImageFileName(kp));
            DBG_LOG("  Handle: %p HandleTableEntry=%p EPROCESS=%p Access=%x", Handle, HandleTableEntry, Object, HandleTableEntry->GrantedAccess);

            if (
                PsGetProcessId(OwningProcess) == 0 // allow System process to hold a handle
                || !strcmp(PsGetProcessImageFileName(OwningProcess), "csrss.exe") // Allow csrss to hold a handle
                )
            {
                DBG_LOG("  This process is whitelisted; OK");
                goto exit_func;
            }

            if (HandleTableEntry->GrantedAccess & PROCESS_VM_OPERATION)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_VM_OPERATION;
                DBG_LOG("  Stripping PROCESS_VM_OPERATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_CREATE_THREAD)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_CREATE_THREAD;
                DBG_LOG("  Stripping PROCESS_CREATE_THREAD");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_DUP_HANDLE)
            {
                HandleTableEntry->GrantedAccess &= ~PROCESS_DUP_HANDLE;
                DBG_LOG("  Stripping PROCESS_CREATE_THREAD");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_QUERY_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_QUERY_INFORMATION);
                DBG_LOG("  Stripping PROCESS_QUERY_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_QUERY_LIMITED_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_QUERY_LIMITED_INFORMATION);
                DBG_LOG("  Stripping PROCESS_QUERY_LIMITED_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_SET_LIMITED_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_SET_LIMITED_INFORMATION);
                DBG_LOG("  Stripping PROCESS_SET_LIMITED_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_SET_INFORMATION)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_SET_INFORMATION);
                DBG_LOG("  Stripping PROCESS_SET_INFORMATION");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_VM_READ)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_VM_READ);
                DBG_LOG("  Stripping PROCESS_VM_READ");
            }
            if (HandleTableEntry->GrantedAccess & PROCESS_VM_WRITE)
            {
                HandleTableEntry->GrantedAccess &= ~(PROCESS_VM_WRITE);
                DBG_LOG("  Stripping PROCESS_VM_READ");
            }
        }
    }

exit_func:;
    //DBG_LOG("Calling ExUnlockHandleTableEntry");
    ExUnlockHandleTableEntry(HandleTable, HandleTableEntry);
    //DBG_LOG("Exiting func");
    return FALSE;
}

void ScanForHandles()
{
    PEPROCESS kp = PsGetCurrentProcess();
    do
    {
        //DBG_LOG("Hello %s", PsGetProcessImageFileName(kp));
        HANDLE pid = PsGetProcessId(kp);
        //DBG_LOG("pid %d", pid);
        if (pid)
        {
            void* objectTable = *(void**)((uintptr_t)kp + 0x418); // +0x418 ObjectTable      : Ptr64 _HANDLE_TABLE
            //DBG_LOG("ObjectTable %p", objectTable);
            if (objectTable)
            {
                HANDLE Handle;
                ExEnumHandleTable(objectTable, MyEnumHandleProcedure, kp, &Handle);
            }
        }

        LIST_ENTRY* list_entry = (uintptr_t)kp + 0x02E8;
        kp = (uintptr_t)list_entry->Flink - 0x02E8;
    } while (kp != PsGetCurrentProcess());
    DBG_LOG("Ok loop complete");
}

NTSTATUS MyLoopThread(void* my_start_info)
{
    while (!IsUnloading)
    {
        ScanForHandles();
        LARGE_INTEGER interval;
        interval.QuadPart = -10000 * 1000;
        KeDelayExecutionThread(KernelMode, FALSE, &interval);
    }
    
    DBG_LOG("Handle stripping thread completes");

    return STATUS_SUCCESS;
}

void UnloadDriver()
{
    // Don't unload multiple times
    if (InterlockedCompareExchange(&IsUnloading, 1, 0) != 0)
        return STATUS_SUCCESS;

    //KDPC myDpc;
    //KeInitializeDpc(&myDpc, MyUnloadRoutine, NULL);
    //KeInsertQueueDpc(&myDpc, NULL, NULL);
    HANDLE hThread;
    PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)MyUnloadRoutine, NULL);

    // remove patch in Null device

    // jk im lazy
}

OB_PREOP_CALLBACK_STATUS MyObjPreCallback(
    _In_ PVOID                         RegistrationContext,
    _In_ POB_PRE_OPERATION_INFORMATION OperationInformation
)
{
    if (!OperationInformation->KernelHandle)
    {
        if (OperationInformation->ObjectType == *PsProcessType)
        {
            PEPROCESS eprocess = OperationInformation->Object;

            char* SrcImageName = PsGetProcessImageFileName(IoGetCurrentProcess());
            char* ProcessImageName = PsGetProcessImageFileName(eprocess);

            if (strstr(ProcessImageName, "doskey.exe")) {
                DBG_LOG("Unload requested");
                UnloadDriver();
            }

            else if (strstr(ProcessImageName, "notepad.exe")) {
                DBG_LOG("%s tries to touch %s", SrcImageName, ProcessImageName);
                DBG_LOG("You ask for permissions %x", OperationInformation->Parameters->CreateHandleInformation.DesiredAccess);
                //if (!strcmp(SrcImageName, "csrss.exe") || !strcmp(SrcImageName, "lsass.exe")) {
                //    DBG_LOG("Ahh fuck it we let csrss do its job... peice of shit");
                //} else {
                //    OperationInformation->Parameters->CreateHandleInformation.DesiredAccess =
                //        SYNCHRONIZE | PROCESS_TERMINATE | PROCESS_SUSPEND_RESUME | PROCESS_CREATE_PROCESS | STANDARD_RIGHTS_REQUIRED | PROCESS_CREATE_THREAD
                //        | PROCESS_QUERY_LIMITED_INFORMATION | PROCESS_QUERY_INFORMATION | PROCESS_SET_SESSIONID | PROCESS_SET_QUOTA
                //        | PROCESS_VM_WRITE | PROCESS_VM_READ | PROCESS_VM_OPERATION;
                //    DBG_LOG("Fuck off don't touch my notepad!!!");
                //}
            }
        }
    }

    return OB_PREOP_SUCCESS;
}

NTSTATUS
    NTSYSAPI
    NTAPI
    ObReferenceObjectByName(
        IN PUNICODE_STRING ObjectPath,
        IN ULONG Attributes,
        IN PACCESS_STATE PassedAccessState,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_TYPE ObjectType,
        IN KPROCESSOR_MODE AccessMode,
        IN OUT PVOID ParseContext,
        OUT PVOID* ObjectPtr);

extern POBJECT_TYPE NTSYSAPI IoDriverObjectType;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
    UCHAR Pad[0x68];
    int Flags;
} *PLDR_DATA_TABLE_ENTRY;

PLDR_DATA_TABLE_ENTRY (NTAPI *MiLookupDataTableEntry)(
    IN  PVOID AddressWithinSection,
    IN  ULONG ResourceHeld
) = 0;

_Use_decl_annotations_
NTSTATUS
DriverEntry(
    MyIrpStruct* my_start_info
    )
{
    DBG_LOG("THIS IS FROM MY MANAUAL MAPPED DRIVER!!!!!!!!!!!1");

    MiLookupDataTableEntry = my_start_info->nt_MiLookupDataTableEntry;
    ExUnlockHandleTableEntry = my_start_info->nt_ExUnlockHandleTableEntry;
    DBG_LOG("MiLookupDataTableEntry at %p", MiLookupDataTableEntry);

    UNICODE_STRING driverName = RTL_CONSTANT_STRING(L"\\Driver\\Null");
    PDRIVER_OBJECT pDriverObj = NULL;

    NTSTATUS out = ObReferenceObjectByName(
        &driverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        0,
        IoDriverObjectType,
        KernelMode,
        NULL,
        (PVOID*)&pDriverObj);

    DBG_LOG("Null device object at %p. code %x", pDriverObj, out);

    DBG_LOG("Null device at %p", pDriverObj->DriverStart);

    PVOID NullDevTextVirtual = (uintptr_t)pDriverObj->DriverStart + 0x1000; // empty space we can use for trampoline

    PLDR_DATA_TABLE_ENTRY Entry = MiLookupDataTableEntry(NullDevTextVirtual, 0);

    if (!Entry)
    {
        DBG_LOG("Wtf? MiLookupDataTableEntry fails");
        return 0;
    }

    DBG_LOG("before flags %x", Entry->Flags);

    Entry->Flags |= 0x20; // Bypass MmVerifyCallbackFunctionCheckFlags

    DBG_LOG("now flags %x", Entry->Flags);

    PHYSICAL_ADDRESS NullTextPhysical = MmGetPhysicalAddress(NullDevTextVirtual);

    // insert trampoline

    DBG_LOG("null device .text at physical %p", NullTextPhysical);

    PVOID MyMapping = MmMapIoSpace(NullTextPhysical, 0x1000, MmNonCached);
    if (!MyMapping)
    {
        DBG_LOG("WTF? MmMapIoSpace fails");
        return STATUS_SUCCESS;
    }

    DBG_LOG("Mapped successfully :)");

    ULONGLONG TrampolineOffset1 = 0x2f0; // some unused space in .text we can jam our trampoline
    ULONGLONG TrampolineOffset2 = TrampolineOffset1 + sizeof(Trampoline); // some unused space in .text we can jam our trampoline

    PUCHAR PatchLocation1 = (uintptr_t)MyMapping + TrampolineOffset1;
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyObjPreCallback;
    memcpy(PatchLocation1, Trampoline, sizeof(Trampoline));

    PUCHAR PatchLocation2 = (uintptr_t)MyMapping + TrampolineOffset2;
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyCreateProcessNotifyRoutine;
    memcpy(PatchLocation2, Trampoline, sizeof(Trampoline));

    DBG_LOG("Patches applied");

    PUCHAR PatchLocationVirtual1 = (uintptr_t)NullDevTextVirtual + TrampolineOffset1;
    PUCHAR PatchLocationVirtual2 = (uintptr_t)NullDevTextVirtual + TrampolineOffset2;

    MmUnmapIoSpace(MyMapping, 0x1000);

    DBG_LOG("Unmapped successfully :)");

    PVOID MyObjPreCallback_Trampoline = PatchLocationVirtual1;
    PVOID MyCreateProcessNotifyRoutine_Trampoline = PatchLocationVirtual2;
    MyCreateProcessNotifyRoutine_Handle = MyCreateProcessNotifyRoutine_Trampoline;

    UNICODE_STRING MyAltitude;
    RtlInitUnicodeString(&MyAltitude, L"123456");

    OB_OPERATION_REGISTRATION MyOperationRegistration[1];
    MyOperationRegistration[0].ObjectType = PsProcessType;
    MyOperationRegistration[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
    MyOperationRegistration[0].PreOperation = MyObjPreCallback_Trampoline;
    MyOperationRegistration[0].PostOperation = NULL;

    OB_CALLBACK_REGISTRATION MyObCallbackInfo;
    MyObCallbackInfo.Version = OB_FLT_REGISTRATION_VERSION;
    MyObCallbackInfo.OperationRegistrationCount = 1;
    MyObCallbackInfo.Altitude = MyAltitude;
    MyObCallbackInfo.RegistrationContext = &MyRegistrationContext;
    MyObCallbackInfo.OperationRegistration = MyOperationRegistration;


    NTSTATUS Result = ObRegisterCallbacks(&MyObCallbackInfo, &MyRegistrationHandle);
    DBG_LOG("ObRegisterCallbacks returns %x", Result);

    HANDLE hThread;
    PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)MyLoopThread, NULL);
    ZwClose(hThread);
    // ObCloseHandle(handle, ExGetPreviousMode());

    Result = PsSetCreateProcessNotifyRoutineEx(MyCreateProcessNotifyRoutine_Trampoline, FALSE);
    DBG_LOG("PsSetCreateProcessNotifyRoutineEx returns %x", Result);

    return STATUS_SUCCESS;
}
