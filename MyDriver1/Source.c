#include <Ntddk.h>
#include <wdm.h>
#include <ntimage.h>

#include "proto.h"

// CHONST!!!!!!!!
#define chonstexpr constexpr
#define chonst const
#define reinterpret_chast reinterpret_cast



// driver mapper shellcode
__int64 __declspec(dllexport) __fastcall MyIRPHandler(struct _DEVICE_OBJECT* a1, IRP* irp)
{
    ULONG ioctl_no = irp->Tail.Overlay.CurrentStackLocation->Parameters.DeviceIoControl.IoControlCode;
    MyIrpStruct* user_data = (MyIrpStruct*)irp->AssociatedIrp.SystemBuffer;

    void* my_rwx = user_data->nt_ExAllocatePoolWithTag(NonPagedPoolExecute, user_data->payload_size, 'lmao');

    user_data->nt_memcpy(my_rwx, user_data->payload, user_data->payload_size);

    // do relocs
    PIMAGE_DOS_HEADER image = (PIMAGE_DOS_HEADER)my_rwx;
    PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS)((uintptr_t)my_rwx + image->e_lfanew);
    IMAGE_DATA_DIRECTORY* reloc_dir_info = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    IMAGE_BASE_RELOCATION* relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)my_rwx + reloc_dir_info->VirtualAddress);

    uintptr_t basediff = (uintptr_t)my_rwx - pe->OptionalHeader.ImageBase;

    void* relocs_end = (void*)((uintptr_t)relocs + reloc_dir_info->Size);
    while (relocs < relocs_end)
    {
        ULONG va = relocs->VirtualAddress;
        USHORT* entries = (USHORT*)((uintptr_t)relocs + sizeof(IMAGE_BASE_RELOCATION));
        int num_entries = (relocs->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(USHORT);
        for (int i = 0; i < num_entries; i++)
        {
            USHORT entry = entries[i];
            USHORT reloc_type = entry >> 12;
            uintptr_t reloc_offset = (uintptr_t)(entry & 0xfff);
            if (reloc_type == IMAGE_REL_BASED_DIR64)
            {
                ULONG64* reloc_spot = (ULONG64*)((uintptr_t)my_rwx + va + reloc_offset);
                *reloc_spot += basediff;
            }
            else if (reloc_type == IMAGE_REL_BASED_ABSOLUTE)
            {
                // this is padding, skip
            }
            else
            {
                // this should never happen
                __debugbreak();
            }
        }
        relocs = (IMAGE_BASE_RELOCATION*)((uintptr_t)relocs + relocs->SizeOfBlock);
    }

    // allocate start context
    void* my_startcontext = user_data->nt_ExAllocatePoolWithTag(NonPagedPoolExecute, sizeof(MyIrpStruct), 'lmao');
    memcpy(my_startcontext, user_data, sizeof(MyIrpStruct));

    // start thread
    HANDLE hThread;
    void* start_addr = (void*)((uintptr_t)my_rwx + 0x1000);
    user_data->nt_PsCreateSystemThread(&hThread, THREAD_ALL_ACCESS, NULL, NULL, NULL, (PKSTART_ROUTINE)start_addr, my_startcontext);

    ((void (*)(PIRP, CCHAR))user_data->nt_IofCompleteRequest)(irp, 0);

    return 0;
}



// actual driver shit

#define DBG_LOG(fmt, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, "[rose][" __FUNCTION__ "] " fmt "\n", ##__VA_ARGS__)

void* MyRegistrationHandle;
void* MyRegistrationContext;

LPCSTR NTSYSAPI NTAPI PsGetProcessImageFileName(PEPROCESS Process);

OB_PREOP_CALLBACK_STATUS MyObjPreCallback(
    _In_ PVOID                         RegistrationContext,
    _In_ POB_PRE_OPERATION_INFORMATION OperationInformation
)
{
    if (!OperationInformation->KernelHandle)
    {
        if (OperationInformation->ObjectType == *PsProcessType)
        {
            PEPROCESS eprocess = OperationInformation->Object;

            char* SrcImageName = PsGetProcessImageFileName(IoGetCurrentProcess());
            char* ProcessImageName = PsGetProcessImageFileName(eprocess);
            DBG_LOG("SrcImageName=%p, ProcessImageName=%p", SrcImageName, ProcessImageName);
            DBG_LOG("%s tries to touch %s", SrcImageName, ProcessImageName);
            if (strstr(ProcessImageName, "notepad.exe")) {
                OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = 0;
                DBG_LOG("Fuck off don't touch my csgo!!!");
            }
        }
    }

    return OB_PREOP_SUCCESS;
}

NTSTATUS
    NTSYSAPI
    NTAPI
    ObReferenceObjectByName(
        IN PUNICODE_STRING ObjectPath,
        IN ULONG Attributes,
        IN PACCESS_STATE PassedAccessState,
        IN ACCESS_MASK DesiredAccess,
        IN POBJECT_TYPE ObjectType,
        IN KPROCESSOR_MODE AccessMode,
        IN OUT PVOID ParseContext,
        OUT PVOID* ObjectPtr);

extern POBJECT_TYPE NTSYSAPI IoDriverObjectType;

typedef struct _KLDR_DATA_TABLE_ENTRY
{
    UCHAR Pad[0x68];
    int Flags;
} *PLDR_DATA_TABLE_ENTRY;

PLDR_DATA_TABLE_ENTRY (NTAPI *MiLookupDataTableEntry)(
    IN  PVOID AddressWithinSection,
    IN  ULONG ResourceHeld
) = 0;

_Use_decl_annotations_
NTSTATUS
DriverEntry(
    MyIrpStruct* my_start_info
    )
{
    DBG_LOG("THIS IS FROM MY MANAUAL MAPPED DRIVER!!!!!!!!!!!1");

    DBG_LOG("ok we waited a lil bit!!!!!!!!!!!1");

    MiLookupDataTableEntry = my_start_info->nt_MiLookupDataTableEntry;
    DBG_LOG("MiLookupDataTableEntry at %p", MiLookupDataTableEntry);

    UNICODE_STRING driverName = RTL_CONSTANT_STRING(L"\\Driver\\Null");
    PDRIVER_OBJECT pDriverObj = NULL;

    NTSTATUS out = ObReferenceObjectByName(
        &driverName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        0,
        IoDriverObjectType,
        KernelMode,
        NULL,
        (PVOID*)&pDriverObj);

    DBG_LOG("Beep object at %p. code %x", pDriverObj, out);

    DBG_LOG("Beep at %p", pDriverObj->DriverStart);

    PVOID BeepTextVirtual = (uintptr_t)pDriverObj->DriverStart + 0x1000;

    PLDR_DATA_TABLE_ENTRY Entry = MiLookupDataTableEntry(BeepTextVirtual, 0);

    if (!Entry)
    {
        DBG_LOG("Wtf? MiLookupDataTableEntry fails");
        return 0;
    }

    DBG_LOG("before flags %x", Entry->Flags);

    Entry->Flags |= 0x20; // Bypass MmVerifyCallbackFunctionCheckFlags

    DBG_LOG("now flags %x", Entry->Flags);

    PHYSICAL_ADDRESS BeepTextPhysical = MmGetPhysicalAddress(BeepTextVirtual);

    // insert trampoline

    DBG_LOG("beep .text at physical %p", BeepTextPhysical);

    PVOID MyMapping = MmMapIoSpace(BeepTextPhysical, 0x1000, MmNonCached);
    if (!MyMapping)
    {
        DBG_LOG("WTF? MmMapIoSpace fails");
        return STATUS_SUCCESS;
    }

    DBG_LOG("Mapped successfully :)");

    PUCHAR PatchLocation = MyMapping;
    DBG_LOG("Original code at patch location : %02x %02x %02x", PatchLocation[0], PatchLocation[1], PatchLocation[2]);
    
    UCHAR Trampoline[] = {
        0x48, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rax, imm64
        0xff, 0xe0 // jmp rax
    };
    *(DWORD64*)(Trampoline + 2) = (DWORD64)MyObjPreCallback;

    memcpy(PatchLocation, Trampoline, sizeof(Trampoline));

    DBG_LOG("Patch applied");

    PUCHAR PatchLocationVirtual = BeepTextVirtual;
    DBG_LOG("New code at patch location : %02x %02x %02x", PatchLocationVirtual[0], PatchLocationVirtual[1], PatchLocationVirtual[2]);

    MmUnmapIoSpace(MyMapping, 0x1000);

    DBG_LOG("Unmapped successfully :)");

    PVOID MyCallbackPtr = PatchLocationVirtual;

    UNICODE_STRING MyAltitude;
    RtlInitUnicodeString(&MyAltitude, L"123456");

    OB_OPERATION_REGISTRATION MyOperationRegistration[1];
    MyOperationRegistration[0].ObjectType = PsProcessType;
    MyOperationRegistration[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
    MyOperationRegistration[0].PreOperation = MyCallbackPtr;
    MyOperationRegistration[0].PostOperation = NULL;

    OB_CALLBACK_REGISTRATION MyObCallbackInfo;
    MyObCallbackInfo.Version = OB_FLT_REGISTRATION_VERSION;
    MyObCallbackInfo.OperationRegistrationCount = 1;
    MyObCallbackInfo.Altitude = MyAltitude;
    MyObCallbackInfo.RegistrationContext = &MyRegistrationContext;
    MyObCallbackInfo.OperationRegistration = MyOperationRegistration;


    NTSTATUS Result = ObRegisterCallbacks(&MyObCallbackInfo, &MyRegistrationHandle);
    DBG_LOG("ObRegisterCallbacks returns %x", Result);

    return STATUS_SUCCESS;
}
